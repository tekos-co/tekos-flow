module.exports = function(RED) {
  "use strict";

  var sdk = require("matrix-js-sdk");

  // --------------------------------------------------------------------------------------------
  // The configuration node holds the configuration and credentials for all nodes.
  function ConvertTimeX(offset) {
    var myDate = new Date(offset);
    var ts_tostring = myDate.toGMTString();
    //		var ts_tolocalstring = " "+myDate.toLocaleString()
    return ts_tostring;
  }
  function ConvertImageX(httpurl) {
    if (httpurl) {
      const offset = "_matrix/media/v1/download";
      //var httpurl = "mxc://matrix.tekos.co/ohkUjHSHAYMhFiatxTkFbKkp";
      var holdUrl = httpurl.substr(6);
      var baseUrl = holdUrl.substr(0, holdUrl.indexOf("/"));
      var imageId = holdUrl.substr(baseUrl.length + 1);

      var httpimageurl =
        "https://" + baseUrl + "/" + offset + "/" + baseUrl + "/" + imageId;
      return httpimageurl;
    } else {
      return null;
    }
  }
  function MatrixBotNode(config) {
    RED.nodes.createNode(this, config);

    // copy "this" object in case we need it in context of callbacks of other functions.
    var node = this;

    node.log("Initializing Matrix Bot node");

    // Configuration options passed by Node Red
    node.userId = config.userId;
    node.room = config.room;

    // TODO: Switch from configuration to credentials and check with if (this.credentials)
    node.accessToken = config.accessToken;
    node.matrixServerURL = config.matrixServerURL;

    node.matrixClient = sdk.createClient({
      baseUrl: node.matrixServerURL,
      accessToken: node.accessToken,
      userId: node.userId
    });

    // If no room is specified, join any room where we are invited
    if (!node.room || node.room === "") {
      node.matrixClient.on("RoomMember.membership", function(event, member) {
        if (member.membership === "invite" && member.userId === node.userId) {
          node.log("Trying to join room " + member.roomId);
          node.matrixClient
            .joinRoom(member.roomId)
            .then(function() {
              node.log(
                "Automatically accepted invitation to join room " +
                  member.roomId
              );
              /*   var out = {
                body: "hello and welcome",
                msgtype: "m.text"
              };
              node.matrixClient
                .sendMessage(member.roomId, out)
                .then(function() {
                  node.log("Message sent: " + out);
                })
                .catch(function(e) {
                  node.warn("Error sending message " + e);
                }); */
            })
            .catch(function(e) {
              node.warn(
                "Cannot join room (probably because I was kicked) " +
                  member.roomId +
                  ": " +
                  e
              );
            });
        }
      });
    }

    node.matrixClient.on("sync", function(state, prevState, data) {
      switch (state) {
        case "ERROR":
          // update UI to say "Connection Lost"
          node.warn("Connection to Matrix server lost");
          node.updateConnectionState(false);
          break;
        case "SYNCING":
          // update UI to remove any "Connection Lost" message
          node.updateConnectionState(true);
          break;
        case "PREPARED":
          // the client instance is ready to be queried.
          node.log("Synchronized to Matrix server.");

          if (node.room) {
            node.log("Trying to join room " + node.room);

            node.matrixClient
              .joinRoom(node.room, { syncRoom: false })
              .then(function(joinedRoom) {
                node.log("Joined " + node.room);
                node.room = joinedRoom.roomId;
                node.updateConnectionState(true);

                //when the bot successufly join the room he send a message
              })
              .catch(function(e) {
                node.warn("Error joining " + node.room + ": " + e);
              });
          } else {
            node.log(
              "No room configured. Will only join rooms where I'm invited"
            );
          }
          break;
      }
    });

    node.log("Connecting to Matrix server...");

    node.matrixClient.startClient();

    // Called when the connection state may have changed
    this.updateConnectionState = function(connected) {
      if (node.connected !== connected) {
        node.connected = connected;
        if (connected) {
          node.emit("connected");
        } else {
          node.emit("disconnected");
        }
      }
    };

    // When Node-RED updates nodes, disconnect from server to ensure a clean start
    node.on("close", function(done) {
      node.log("Matrix configuration node closing...");
      if (node.matrixClient) {
        node.log("Disconnecting from Matrix server...");
        node.matrixClient.stopClient();
        node.updateConnectionState(false);
      }
      done();
    });
  }

  RED.nodes.registerType("matrix bot", MatrixBotNode);

  // --------------------------------------------------------------------------------------------
  // The output node sends a message to the chat.

  function MatrixOutNode(config) {
    RED.nodes.createNode(this, config);

    // copy "this" object in case we need it in context of callbacks of other functions.
    var node = this;

    // Configuration options passed by Node Red
    node.configNode = RED.nodes.getNode(config.bot);

    node.configNode.on("connected", function() {
      node.status({ fill: "green", shape: "ring", text: "connected" });
    });

    node.configNode.on("disconnected", function() {
      node.status({ fill: "red", shape: "ring", text: "disconnected" });
    });

    this.on("input", function(msg) {
      if (!node.configNode || !node.configNode.matrixClient) {
        node.warn("No configuration");
        return;
      }

      if (msg.payload) {
        node.log("Sending message " + msg.payload);

        var destRoom = "";
        if (msg.roomId) {
          destRoom = msg.roomId;
        } else if (node.configNode.room) {
          destRoom = node.configNode.room;
        } else {
          node.warn("Room must be specified in msg.roomId or in configuration");
          return;
        }
        var out = ConverPayLoadToMatrix(msg.payload);
        node.configNode.matrixClient
          .sendMessage(destRoom, out)
          .then(function() {
            node.log("Message sent: " + out);
          })
          .catch(function(e) {
            node.warn("Error sending message " + e);
          });
      } else {
        node.warn("msg.payload is empty");
      }
    });

    this.on("close", function(done) {
      node.log("Matrix out node closing...");
      done();
    });
  }

  RED.nodes.registerType("matrix sender", MatrixOutNode);

  function ConverPayLoadToMatrix(msg) {
    var payload = null;
    if (msg.type == "message") {
      payload = {
        body: msg.content,
        msgtype: "m.text"
      };
    }
    if (msg.type == "media") {
      var imagetekos = msg.medias[0];
      if (imagetekos) {
        payload = {
          body: "",
          msgtype: "m.text",
          tekosimage: {
            smallimage: imagetekos.src,
            bigimage: imagetekos.src,
            alt: imagetekos.label
          }
        };
      } else {
        console.log(
          "an error has occured, please check that you have specisifed an image first"
        );
      }
    }
    if (msg.type == "inline-buttons") {
      payload = {
        body: msg.content,
        msgtype: "m.text",
        hints: []
      };
      msg.buttons.forEach(element => {
        var bj = {
          body: element.label,
          reply: element.value,
          type: element.type
        };

        if (element.type == "url") {
          bj.type = "url";
          bj.value = element.url;
        }
        if (element.type == "postback") {
          bj.type = "postback";
          bj.value = element.value;
        }
        payload.hints.push(bj);
      });
    }
    if (msg.type == "generic-template") {
      payload = {
        body: "",
        msgtype: "m.text",
        cards: []
      };
      msg.elements.forEach(element => {
        var bj = {
          body: element.title,
          title: element.subtitle,
          img: element.imageUrl,
          buttons: element.buttons
        };

        payload.cards.push(bj);
      });
      console.log(payload);
    }
    if (msg.type == "form") {
      var payload = {
        body: "",
        msgtype: "m.text",
        titleform: msg.form.title,
        posturl: msg.form.posturl,
        buttontitle: msg.form.message,
        tekosform: []
      };
      msg.form.inputs.forEach(element => {
        var bj;
        if (element.type == "input") {
          bj = {
            type: element.type,
            subtype: element.subtype,
            label: element.label,
            key: element.name
          };
        } else if (element.type == "select") {
          bj = {
            type: element.type,
            subtype: element.subtype,
            label: element.label,
            key: element.name,
            multi: !!element.multi,
            options: []
          };
          if (element.options.length > 1) {
            element.options.forEach(option => {
              bj.options.push(option);
            });
          }
        } else if (element.type == "editor") {
          bj = {
            type: element.type,
            label: element.label,
            key: element.name,
            mode: element.mode || "json"
          };
        }

        payload.tekosform.push(bj);
      });
    }
    console.log(payload);
    return payload;
  }
  // --------------------------------------------------------------------------------------------
  // The input node receives messages from the chat.

  function MatrixInNode(config) {
    RED.nodes.createNode(this, config);

    // copy "this" object in case we need it in context of callbacks of other functions.
    var node = this;
    node.configNode = RED.nodes.getNode(config.bot);

    node.log("MatrixInNode initializing...");

    if (!node.configNode) {
      node.warn("No configuration node");
      return;
    }

    node.status({ fill: "red", shape: "ring", text: "disconnected" });

    node.configNode.on("disconnected", function() {
      node.status({ fill: "red", shape: "ring", text: "disconnected" });
    });

    node.configNode.on("connected", function() {
      node.status({ fill: "green", shape: "ring", text: "connected" });
      node.configNode.matrixClient.on("Room.timeline", function(
        event,
        room,
        toStartOfTimeline,
        data
      ) {
        /*   console.log("### #### #### ### #### #### ### #### ####");
        console.log(event.getType()); */
        if (event.getType() == "m.room.guest_access") {
          var room_event = {
            room: event.event.room_id,
            event: event
          };
          node.send(room_event);
          node.warn(room_event);
          return room_event;
          /*       if (config.start && config.start != "") {
            let roomid = event.event.room_id;
            var out = {
              msgtype: "m.text",
              body: config.start
            };
            node.configNode.matrixClient
              .sendMessage(roomid, out)
              .then(function() {
                node.log("Message sent: " + out);
              })
              .catch(function(e) {
                node.warn("Error sending message " + e);
              });
          } */
        }
        if (toStartOfTimeline) {
          return; // don't print paginated results
        }
        if (event.getType() !== "m.room.message") {
          return; // only keep messages
        }
        if (
          !event.getSender() ||
          event.getSender() === node.configNode.userId
        ) {
          return; // ignore our own messages
        }
        if (!event.getUnsigned() || event.getUnsigned().age > 1000) {
          return; // ignore old messages
        }
        // TODO process messages other than text
        node.log(
          // the room name will update with m.room.name events automatically
          "Received chat message: (" +
            room.name +
            ") " +
            event.getSender() +
            " :: " +
            event.getContent().body
        );
        console.log(event);
        var msg = {
          event: event,
          id: event.event.event_id,
          payload: event.getContent().body,
          messageContent: event.getContent().body,
          senderId: event.getSender(),
          channelId: "",
          roomId: room.roomId,
          imagesrc: ConvertImageX(event.event.content.url),
          participants: "",
          createdAt: ConvertTimeX(event.event.origin_server_ts)
        };

        node.send(msg);
        node.warn(msg);
        return msg;
      });
    });

    this.on("close", function(done) {
      node.log("Matrix in node closing...");
      done();
    });
  }

  RED.nodes.registerType("matrix receiver", MatrixInNode);

  // --------------------------------------------------------------------------------------------
  // The command node receives messages from the chat.

  function MatrixCommandNode(config) {
    RED.nodes.createNode(this, config);

    // copy "this" object in case we need it in context of callbacks of other functions.
    var node = this;
    node.command = config.command;
    node.configNode = RED.nodes.getNode(config.bot);

    node.log("MatrixCommandNode initializing...");

    if (!node.configNode) {
      node.warn("No configuration node");
      return;
    }

    node.status({ fill: "red", shape: "ring", text: "disconnected" });

    node.configNode.on("disconnected", function() {
      node.status({ fill: "red", shape: "ring", text: "disconnected" });
    });

    node.configNode.on("connected", function() {
      node.status({ fill: "green", shape: "ring", text: "connected" });
      node.configNode.matrixClient.on("Room.timeline", function(
        event,
        room,
        toStartOfTimeline,
        data
      ) {
        if (toStartOfTimeline) {
          return; // don't print paginated results
        }
        if (event.getType() !== "m.room.message") {
          return; // only keep messages
        }
        if (
          !event.getSender() ||
          event.getSender() === node.configNode.userId
        ) {
          return; // ignore our own messages
        }
        if (!event.getUnsigned() || event.getUnsigned().age > 1000) {
          return; // ignore old messages
        }
        // TODO process messages other than text
        node.log(
          // the room name will update with m.room.name events automatically
          "Received zchat message: (" +
            room.name +
            ") " +
            event.getSender() +
            " :: " +
            event.getContent().body
        );

        var message = event.getContent().body;

        var tokens = message.split(" ");
        if (tokens[0] == node.command) {
          node.log("Recognized command " + node.command + "  Processing...");
          var remainingText = message.replace(node.command, "");
          var msg = {
            payload: remainingText,
            sender: event.getSender(),
            roomId: room.roomId,
            imagesrc: event.event.content.url,
            originalMessage: message
          };

          node.send([msg, null]);
        }
      });
    });

    this.on("close", function(done) {
      node.log("Matrix command node closing...");
      done();
    });
  }

  RED.nodes.registerType("matrix command", MatrixCommandNode);
};
